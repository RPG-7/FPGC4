Checklist
This file is a crappy note checklist for verifying that the FPGC4 works.

[x] CPU instructions
halt 	y
read 	y,y
write	y
copy	y
push 	y
pop		y
jump 	y,y
jumpr	y,y
load 	y,y
beq 	y
bne		y
bgt 	y
bge 	y
savpc	y
reti 	y
arith 	y

TODO:
[x] When on FPGA, write a simple test rom
[ ] When assembler updated, write a big test rom

Things that can go wrong in hardware:
SDRAM timing not good 											false, it works fine
timing requirements not met (should get warning)				true, however, it works fine for 25MHz
SPI timings not good 											false, it works fine
some same clock timing thing that i missed in simulation 		false, afik
miswire in quartus top level (should look at warnings) 			false, all wires are connected correctly

Logs:
writing to spi results in a read by MU, and nothing happens in cpu because read_mem is low for writing instructions
PC only handles interrupts when PC is smaller than the internal ROM address

Need to put this in the readme somewhere under new hardware connection section
Display pinout FPGA side (header U7)
1.	gnd
2.	gnd
3.	3v
4.	3v
5.	gnd
6.	gnd
7.	clk 	r1
8. 	blk 	r2
9.	hs 		p1
10.	vs 		p2
11.	r2 		n1
12.	r1 		n2
13.	r0 		m1
14.	g2 		m2
15.	g1 		j1
16. g0 		j2
17. b1 		h1
18. b0 		h2









FSX2 features:
480x256 resolution, 60x32 tiles

32bit addresses:
256 tile pattern table -> 2 bits per pixel -> 128 bits per tile -> 4KiB of VRAM
32 palettes -> 8 bits per color -> 4 colors -> 128 bytes of VRAM

8bit addresses:
512x256 BG tile and BG color table for main bg with horizontal scrolling (4 tiles of scrolling room)
	64x32 tiles	512x256x2 = 4KiB of VRAM
	2048 tiles

512x256 Window tile and Window color table without scrolling, always on top of main table, rightmost 16x256 pixels (4 columns) not used
	64x32 tiles 512x256x2 = 4KiB of VRAM
	2048 tiles

2 registers, also in VRAM (8) avoid crossing clock domains:
- XscrollTile 	X tile window offset	6 bits -> 64
- XscrollFine 	X pixel offset 			3 bits -> 8

8192 + 2 addresses at 8 bits


New memory map:
0x000000 to 0x7FFFFF -> SDRAM 		32MiB 		@ 32bit (8388608 addresses)
0x800000 to 0xBFFFFF -> SPI FLASH 	16MiB 		@ 32bit (4194304 addresses)

0xC00000 to 0xC0041F -> VRAM32 		4.125KiB 	@ 32bit (1024+32 addresses)

0xC00420 to 0xC02421 -> VRAM8 		~8KiB @ 8bit	(4*2048 + 2  addresses)

0xC02422 to 0xC02622 -> ROM 		2KiB 		@ 32bit (512 	 addresses)

0xC02622  		 	 -> (S)NES controller
0xC02623 to hC02625 -> PS/2 Keyboard
0xC02626 			 -> GPIO
0xC02627 to 0x?????? -> Future I/O



Rendering:
No linebuffer. 8 fetches per tile.

Read scroll values at vblank, store in register so it can be read the entire frame

Tile scroll by address offset formula
How to do fine scroll:
	- also render the 65th tile horizontally
	- start rendering x pixels earlier (in blanking)
		- Start at position HSTART - XscrollFine

Use async statemachine based on hcounter and vcounter
